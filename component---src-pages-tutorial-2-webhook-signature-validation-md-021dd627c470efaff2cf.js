"use strict";(self.webpackChunkcloudmanager_api_docs=self.webpackChunkcloudmanager_api_docs||[]).push([[927],{45112:function(e,t,n){n.r(t),n.d(t,{_frontmatter:function(){return p},default:function(){return m}});var o,a=n(87462),r=n(63366),i=(n(15007),n(64983)),s=n(99536),d=n(77402),l=["components"],p={},u=(o="InlineAlert",function(e){return console.warn("Component "+o+" was not imported, exported, or provided by MDXProvider as global scope"),(0,i.mdx)("div",e)}),h={_frontmatter:p},c=s.Z;function m(e){var t=e.components,n=(0,r.Z)(e,l);return(0,i.mdx)(c,(0,a.Z)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,i.mdx)("h1",{id:"tutorial-step-2---webhook-signature-validation"},"Tutorial Step 2 - Webhook Signature Validation"),(0,i.mdx)("p",null,"In the second step of the tutorial, the webhook from the first step is going to be enhanced to validate that the POST request actually comes from Adobe I/O."),(0,i.mdx)("p",null,"POST requests to the webhook are signed using a SHA256 HMAC stored in the ",(0,i.mdx)("inlineCode",{parentName:"p"},"x-adobe-signature")," header. There's a few different ways this can be done, but the approach used in this tutorial is using the ",(0,i.mdx)("inlineCode",{parentName:"p"},"verify")," feature of the ",(0,i.mdx)("inlineCode",{parentName:"p"},"body-parser")," package. This uses a function which is called on every request. If an error is thrown inside this function, the request is immediately rejected. This helps to keep the route function clean."),(0,i.mdx)("h2",{id:"setting-up-the-secret-key"},"Setting up the Secret Key"),(0,i.mdx)("p",null,"The ",(0,i.mdx)("inlineCode",{parentName:"p"},"x-adobe-signature")," header value is generated using the Client Secret value, so the first step is to make sure the ",(0,i.mdx)("inlineCode",{parentName:"p"},".env")," file has the ",(0,i.mdx)("inlineCode",{parentName:"p"},"CLIENT_SECRET")," variable populated. You should have done this in Step 0, but if not (or if you are using Glitch), you will need to do this now."),(0,i.mdx)("h2",{id:"using-the-crypto-library"},"Using the crypto library"),(0,i.mdx)("p",null,"Node.js's standard ",(0,i.mdx)("inlineCode",{parentName:"p"},"crypto")," module supports all of the cryptographic functions needed for this. It just needs to be added to the top of the script:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-javascript"},'const express = require("express"),\n  bodyParser = require("body-parser"),\n  crypto = require("crypto");\n')),(0,i.mdx)("h2",{id:"writing-the-verify-function"},"Writing the ",(0,i.mdx)("inlineCode",{parentName:"h2"},"verify")," function"),(0,i.mdx)("p",null,"The actual ",(0,i.mdx)("inlineCode",{parentName:"p"},"verify")," function accepts the request and response objects along with a Node.js ",(0,i.mdx)("inlineCode",{parentName:"p"},"Buffer"),". It first reads the signature from the headers. Then it generates the HMAC using the ",(0,i.mdx)("inlineCode",{parentName:"p"},"Buffer"),". Finally, it compares a Base64 digest of the HMAC to the header value."),(0,i.mdx)("p",null,"We also need to handle the case where the header isn't provided, so an ",(0,i.mdx)("inlineCode",{parentName:"p"},"Error")," should be thrown if there is no signature ",(0,i.mdx)("strong",{parentName:"p"},"and")," the request is a POST request."),(0,i.mdx)(u,{slots:"text",mdxType:"InlineAlert"}),(0,i.mdx)("p",null,"There might be cases where you want to disable this checked, so the code below allows for a ",(0,i.mdx)("inlineCode",{parentName:"p"},"DEBUG")," variable to be set in ",(0,i.mdx)("inlineCode",{parentName:"p"},".env")," to allow unsigned POSTs through."),(0,i.mdx)("p",null,"Fully implemented, the ",(0,i.mdx)("inlineCode",{parentName:"p"},"verify")," function looks like this:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-javascript"},'app.use(\n  bodyParser.json({\n    verify: (req, res, buf, encoding) => {\n      const signature = req.header("x-adobe-signature");\n      if (signature) {\n        const hmac = crypto.createHmac("sha256", process.env.CLIENT_SECRET);\n        hmac.update(buf);\n        const digest = hmac.digest("base64");\n\n        if (signature !== digest) {\n          throw new Error("x-adobe-signature HMAC check failed");\n        }\n      } else if (!process.env.DEBUG && req.method === "POST") {\n        throw new Error("x-adobe-signature required");\n      }\n    },\n  })\n);\n')),(0,i.mdx)("h2",{id:"updating-the-webhook"},"Updating the Webhook"),(0,i.mdx)("p",null,"To update your webhook script, just replace the line"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-javascript"},"app.use(bodyParser.json());\n")),(0,i.mdx)("p",null,"with the block above. If you are running the script locally, you'll need to stop and restart the node process. You don't need to restart ngrok. In fact, if you do restart ngrok, the URL will likely change and you'll need to go back into the ",(0,i.mdx)("a",{href:"https://console.adobe.io/integrations",target:"_new"},"Adobe I/O Console")," and update the Webhook URL."),(0,i.mdx)("p",null,"If you are running the script through Glitch, Glitch will restart automatically. If you don't want to update your existing Glitch project (or lost it), you can click the button below to start over."),(0,i.mdx)(d.Z,{projectName:"adobe-cloudmanager-api-tutorial-step2",mdxType:"Glitch"}),(0,i.mdx)("h2",{id:"next-step"},"Next Step"),(0,i.mdx)("p",null,"With all that done, you're ready to proceed to the next step. Continue to ",(0,i.mdx)("a",{parentName:"p",href:"3-handling-specific-events.md"},"Step 3"),"."))}m.isMDXComponent=!0}}]);
//# sourceMappingURL=component---src-pages-tutorial-2-webhook-signature-validation-md-021dd627c470efaff2cf.js.map